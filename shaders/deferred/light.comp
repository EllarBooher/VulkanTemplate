#version 460
#extension GL_EXT_buffer_reference2 : require

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba16, set = 0, binding = 0) uniform image2D image;

layout(set = 1, binding = 0) uniform sampler2D gbuffer_Diffuse;
layout(set = 1, binding = 1) uniform sampler2D gbuffer_Specular;
layout(set = 1, binding = 2) uniform sampler2D gbuffer_Normal;
layout(set = 1, binding = 3) uniform sampler2D gbuffer_WorldPosition;
layout(set = 1, binding = 4) uniform sampler2D gbuffer_OcclusionRoughnessMetallic;

layout(r16, set = 2, binding = 0) uniform image2D inputAO;

layout(set = 3, binding = 0) uniform sampler2D shadowmap;

struct GBufferTexel
{
    vec4 position;
    vec4 normal;
    vec4 diffuseColor;
    vec4 specularColor;
    vec4 occlusionRoughnessMetallic;
};

struct PBRTexel
{
    vec3 position;
    vec3 normal;
    vec3 subscatteringColor;
    vec3 normalReflectance;
    float occlusion;
    float specularPower;
    float metallic;
};

GBufferTexel sampleGBuffer(const vec2 uv)
{
    GBufferTexel texel;
    texel.diffuseColor = texture(gbuffer_Diffuse, uv);
    texel.specularColor = texture(gbuffer_Specular, uv);
    texel.normal = texture(gbuffer_Normal, uv);
    texel.position = texture(gbuffer_WorldPosition, uv);
    texel.occlusionRoughnessMetallic = texture(gbuffer_OcclusionRoughnessMetallic, uv);

    return texel;
}

float max3(const vec3 rgb) { return max(max(rgb.r, rgb.g), rgb.b); }

PBRTexel convertPBRProperties(const GBufferTexel gbuffer)
{
    const float specularPower = 160;

    const vec3 dialectricReflectence = vec3(0.04);
    const vec3 metallicReflectence = vec3(0.5) * gbuffer.specularColor.rgb / max3(gbuffer.specularColor.rgb);

    const float metallic = gbuffer.occlusionRoughnessMetallic.b;

    return PBRTexel(
        /* position = */ gbuffer.position.xyz,
        /* normal = */ gbuffer.normal.xyz,
        /* subscatteringColor = */ gbuffer.diffuseColor.rgb,
        /* normalReflectance = */ mix(dialectricReflectence, metallicReflectence, metallic),
        /* occlusion = */ gbuffer.occlusionRoughnessMetallic.r,
        /* roughness = */ pow(specularPower, 1.0 - gbuffer.occlusionRoughnessMetallic.g),
        /* metallic = */ metallic);
}

vec3 computeFresnel(const PBRTexel material, const vec3 lightOutgoing, const vec3 viewOutgoing)
{
    const vec3 halfwayDirection = normalize(lightOutgoing + viewOutgoing);

    // Schlick approximation of fresnel reflection
    const vec3 fresnel =
        material.normalReflectance
        + (1.0 - material.normalReflectance) * pow(1.0 - clamp(dot(halfwayDirection, lightOutgoing), 0.0, 1.0), 5);

    return fresnel;
}

vec3 diffuseBRDF(const PBRTexel material, const vec3 lightOutgoing)
{
    // Lambertian BRDF

    return material.subscatteringColor / 3.14159265359;
}

vec3 specularBRDF(const PBRTexel material, const vec3 lightOutgoing, const vec3 viewOutgoing)
{
    const vec3 halfwayDirection = normalize(lightOutgoing + viewOutgoing);

    const float specularPower = material.specularPower;
    const float microfacetDistribution = pow(clamp(dot(halfwayDirection, material.normal), 0.0, 1.0), specularPower);

    // Without this term, the overall brightness decreases as roughness increases
    const float normalizationTerm = (specularPower + 2) / 8.0;

    return vec3(normalizationTerm * microfacetDistribution);
}

layout(push_constant) uniform PushConstant
{
    vec2 offset;
    vec2 gBufferCapacity;

    vec4 cameraPosition;

    vec4 lightForward;

    mat4 cameraProjView;

    vec2 extent;
    float lightStrength;
    float ambientStrength;

    vec2 padding0;
    float shadowReceiverPlaneDepthBias;
    bool gbufferWhiteOverride;

    mat4 lightProjView;

    uvec2 shadowMapSize;
    float shadowReceiverConstantBias;
    bool enableShadows;
} pc;

layout(constant_id = 0) const bool enableAO = false;

vec3 computeLightContribution(const vec3 lightForward, const PBRTexel material, const vec3 viewDirection)
{
    // Our model uses a microfacet specular BRDF layered with a diffuse BRDF
    // The assumption is that all diffuse light is scattered from whatever is not reflected as a specular highlight

    const vec3 lightDirection = normalize(-lightForward);

    const vec3 diffuseContribution = diffuseBRDF(material, lightDirection);
    const vec3 specularContribution = specularBRDF(material, lightDirection, viewDirection);

    const vec3 fresnel = computeFresnel(material, lightDirection, viewDirection);

    // Lerping preserves the energy conservation of our BRDFs
    return pc.lightStrength * material.occlusion * mix(diffuseContribution, specularContribution, fresnel)
         * clamp(dot(material.normal, lightDirection), 0.0, 1.0);
}

// clang-format off
const mat4 TO_TEX_COORD_MAT = mat4(
	0.5, 0.0, 0.0, 0.0,
	0.0, 0.5, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.5, 0.5, 0.0, 1.0
);
// clang-format on

vec4 computeShadowCoord(
    const mat4 lightProjView, 
    const vec3 lightIncident, 
    const vec3 position, 
    const vec3 normal
)
{
    // Scale the bias by the size of a texel in shadow space
    // coords run from (-1,-1) to (1,1) so we multiply by 2
    const float texelSize = 2.0 / pc.shadowMapSize.x;
    const float angleFactor = clamp(1.0 - dot(-lightIncident, normal), 0.0, 1.0);
    const float bias = angleFactor * texelSize * pc.shadowReceiverPlaneDepthBias;

    vec4 shadowCoord = TO_TEX_COORD_MAT * lightProjView * vec4(position + bias * normal, 1.0);
    shadowCoord /= shadowCoord.w;

    return shadowCoord;
}

float sampleShadow_PCF(
    sampler2D map, 
    const vec4 shadowCoord
)
{
    if(!pc.enableShadows)
    {
        return 1.0;
    }

    const ivec2 shadowmapDimensions = textureSize(map, 0);

    const float dx = 1.0 / float(shadowmapDimensions.x);
    const float dy = 1.0 / float(shadowmapDimensions.y);

    float summedDistance = 0.0;

    const int SAMPLE_RANGE = 2;
    const int SAMPLE_COUNT = (2 * SAMPLE_RANGE + 1) * (2 * SAMPLE_RANGE + 1);

    const float fragmentDepth = shadowCoord.z;

    for (int y = -SAMPLE_RANGE; y <= SAMPLE_RANGE; y++)
    {
        for (int x = -SAMPLE_RANGE; x <= SAMPLE_RANGE; x++)
        {
            const vec2 offsetShadowCoord = shadowCoord.xy + vec2(x * dx, y * dy);
            const float occluderDepth = texture(map, offsetShadowCoord).r;

            // Reverse-Z
            if (occluderDepth > 0.0 && occluderDepth > fragmentDepth + pc.shadowReceiverConstantBias)
            {
                summedDistance += 1.0;
            }
        }
    }

    return 1.0 - summedDistance / SAMPLE_COUNT;
}


void main()
{
    const vec2 size = imageSize(image);
    const ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy + pc.offset);
    if (texelCoord.x >= size.x || texelCoord.y >= size.y)
    {
        return;
    }

    // The uv needs to be offset to avoid floating point errors on texel boundaries
    const vec2 offset = vec2(0.5, 0.5);
    const vec2 gbufferUV = (vec2(texelCoord) + offset) / pc.gBufferCapacity;

    GBufferTexel gbufferTexel = sampleGBuffer(gbufferUV);

    // No transparent geometry for now, less than 1.0 alpha indicates background texels
    if (gbufferTexel.diffuseColor.a < 1.0)
    {
        return;
    }

    if(pc.gbufferWhiteOverride)
    {
        gbufferTexel.diffuseColor = vec4(1.0);
        gbufferTexel.specularColor = vec4(1.0);
    }

    const PBRTexel material = convertPBRProperties(gbufferTexel);

    const vec3 viewDirection = normalize(pc.cameraPosition.xyz - material.position.xyz);

    // Slightly offset light
    const vec3 lightForward = normalize(pc.lightForward.xyz);
    const vec4 shadowCoord = computeShadowCoord(
        pc.lightProjView, 
        pc.lightForward.xyz, 
        material.position.xyz, 
        material.normal.xyz
    );
    const float shadowTransmittance = sampleShadow_PCF(
        shadowmap, 
        shadowCoord
    );

    const vec3 lightContribution = shadowTransmittance * computeLightContribution(lightForward, material, viewDirection);

    float aoTransmittance = 1.0;
    if (enableAO)
    {
        aoTransmittance = imageLoad(inputAO, texelCoord).r;
    }

    const vec3 ambientContribution = vec3(pc.ambientStrength) * material.subscatteringColor * aoTransmittance;

    const vec3 totalLight = lightContribution + ambientContribution;
    imageStore(image, texelCoord, vec4(totalLight, 1.0));
}